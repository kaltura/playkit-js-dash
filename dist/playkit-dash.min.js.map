{"version":3,"sources":["webpack:///dash/webpack/universalModuleDefinition","webpack:///dash/playkit-dash.min.js","webpack:///dash/webpack/bootstrap b043c7de86c1cf8ad84e","webpack:///dash/./dash-adapter.js","webpack:///dash/external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":\"shaka\"}","webpack:///dash/external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","_get","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_shakaPlayer","_shakaPlayer2","obj","default","_playkitJs","DashAdapter","_BaseMediaSourceAdapt","videoElement","source","config","arguments","_logger","debug","Player","version","_this","_shaka","configure","_addBindings","playback","options","html5","dash","mimeType","canPlayType","toLowerCase","_dashMimeType","toString","polyfill","installAll","isSupported","isBrowserSupported","addEventListener","_onAdaptation","bind","_onError","removeEventListener","_this2","_loadPromise","Promise","resolve","reject","_sourceObj","url","load","then","data","tracks","_getParsedTracks","catch","error","_removeBindings","destroy","variantTracks","getVariantTracks","activeVariantTrack","filter","variantTrack","active","audioId","videoId","videoTracks","_getParsedVideoTracks","audioTracks","_getParsedAudioTracks","textTracks","_getParsedTextTracks","concat","_getVideoTracks","parsedTracks","settings","id","bandwidth","label","index","push","VideoTrack","_getAudioTracks","language","AudioTrack","getTextTracks","kind","TextTrack","videoTrack","selectedVideoTrack","abr","enabled","selectVariantTrack","_onTrackChanged","audioTrack","selectAudioLanguage","textTrack","selectTextLanguage","setTextTrackVisibility","BaseMediaSourceAdapter","getLogger","registerMediaSourceAdapter"],"mappings":"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","file":"playkit-dash.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"shaka-player\"), require(\"playkit-js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"shaka-player\", \"playkit-js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsDash\"] = factory(require(\"shaka-player\"), require(\"playkit-js\"));\n\telse\n\t\troot[\"PlaykitJsDash\"] = factory(root[\"shaka\"], root[\"Playkit\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"shaka-player\"), require(\"playkit-js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"shaka-player\", \"playkit-js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsDash\"] = factory(require(\"shaka-player\"), require(\"playkit-js\"));\n\telse\n\t\troot[\"PlaykitJsDash\"] = factory(root[\"shaka\"], root[\"Playkit\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shakaPlayer = __webpack_require__(1);\n\nvar _shakaPlayer2 = _interopRequireDefault(_shakaPlayer);\n\nvar _playkitJs = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Adapter of shaka lib for dash content\n * @classdesc\n */\nvar DashAdapter = function (_BaseMediaSourceAdapt) {\n  _inherits(DashAdapter, _BaseMediaSourceAdapt);\n\n  _createClass(DashAdapter, null, [{\n    key: 'createAdapter',\n\n\n    /**\n     * Factory method to create media source adapter.\n     * @function createAdapter\n     * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n     * @param {Object} source - The source Object.\n     * @param {Object} config - The player configuration.\n     * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n     * @static\n     */\n\n    /**\n     * The shaka player instance\n     * @member {any} _shaka\n     * @private\n     */\n\n    /**\n     * The load promise\n     * @member {Promise<Object>} - _loadPromise\n     * @type {Promise<Object>}\n     * @private\n     */\n\n    /**\n     * The adapter logger\n     * @member {any} _logger\n     * @private\n     * @static\n     */\n    value: function createAdapter(videoElement, source, config) {\n      return new this(videoElement, source, config.playback.options.html5.dash);\n    }\n\n    /**\n     * Checks if dash adapter can play a given mime type\n     * @function canPlayType\n     * @param {string} mimeType - The mime type to check\n     * @returns {boolean} - Whether the dash adapter can play a specific mime type\n     * @static\n     */\n\n    /**\n     * The supported mime type by the dash adapter\n     * @member {string} _dashMimeType\n     * @static\n     * @private\n     */\n\n    /**\n     * The id of Adapter\n     * @member {string} id\n     * @static\n     * @public\n     */\n\n  }, {\n    key: 'canPlayType',\n    value: function canPlayType(mimeType) {\n      var canPlayType = typeof mimeType === 'string' ? mimeType.toLowerCase() === DashAdapter._dashMimeType : false;\n      DashAdapter._logger.debug('canPlayType result for mimeType: ' + mimeType + ' is ' + canPlayType.toString());\n      return canPlayType;\n    }\n\n    /**\n     * Checks if the dash adapter is supported\n     * @function isSupported\n     * @returns {boolean} -  Whether dash is supported.\n     * @static\n     */\n\n  }, {\n    key: 'isSupported',\n    value: function isSupported() {\n      _shakaPlayer2.default.polyfill.installAll();\n      var isSupported = _shakaPlayer2.default.Player.isBrowserSupported();\n      DashAdapter._logger.debug('isSupported:' + isSupported);\n      return isSupported;\n    }\n\n    /**\n     * @constructor\n     * @param {HTMLVideoElement} videoElement - The video element which bind to the dash adapter\n     * @param {Object} source - The source object\n     * @param {Object} config - The media source adapter configuration\n     */\n\n  }]);\n\n  function DashAdapter(videoElement, source) {\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, DashAdapter);\n\n    DashAdapter._logger.debug('Creating adapter. Shaka version: ' + _shakaPlayer2.default.Player.version);\n\n    var _this = _possibleConstructorReturn(this, (DashAdapter.__proto__ || Object.getPrototypeOf(DashAdapter)).call(this, videoElement, source, config));\n\n    _this._shaka = new _shakaPlayer2.default.Player(videoElement);\n    _this._shaka.configure(config);\n    _this._addBindings();\n    return _this;\n  }\n\n  /**\n   * Add the required bindings to shaka.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n\n\n  _createClass(DashAdapter, [{\n    key: '_addBindings',\n    value: function _addBindings() {\n      this._shaka.addEventListener('adaptation', this._onAdaptation.bind(this));\n      this._shaka.addEventListener('error', this._onError.bind(this));\n    }\n\n    /**\n     * Remove the bindings to shaka.\n     * @function _removeBindings\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_removeBindings',\n    value: function _removeBindings() {\n      this._shaka.removeEventListener('adaptation', this._onAdaptation);\n      this._shaka.removeEventListener('error', this._onError);\n    }\n\n    /**\n     * Load the video source\n     * @function load\n     * @override\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var _this2 = this;\n\n      if (!this._loadPromise) {\n        this._loadPromise = new Promise(function (resolve, reject) {\n          if (_this2._sourceObj && _this2._sourceObj.url) {\n            _this2._shaka.load(_this2._sourceObj.url).then(function () {\n              var data = { tracks: _this2._getParsedTracks() };\n              DashAdapter._logger.debug('The source has been loaded successfully');\n              resolve(data);\n            }).catch(function (error) {\n              reject(error);\n              _this2._onError(error);\n            });\n          }\n        });\n      }\n      return this._loadPromise;\n    }\n\n    /**\n     * Destroying the dash adapter\n     * @function destroy\n     * @override\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      DashAdapter._logger.debug('destroy');\n      _get(DashAdapter.prototype.__proto__ || Object.getPrototypeOf(DashAdapter.prototype), 'destroy', this).call(this);\n      this._loadPromise = null;\n      this._removeBindings();\n      this._shaka.destroy();\n    }\n\n    /**\n     * Get the original video tracks\n     * @function _getVideoTracks\n     * @returns {Array<Object>} - The original video tracks\n     * @private\n     */\n\n  }, {\n    key: '_getVideoTracks',\n    value: function _getVideoTracks() {\n      var variantTracks = this._shaka.getVariantTracks();\n      var activeVariantTrack = variantTracks.filter(function (variantTrack) {\n        return variantTrack.active;\n      })[0];\n      var videoTracks = variantTracks.filter(function (variantTrack) {\n        return variantTrack.audioId === activeVariantTrack.audioId;\n      });\n      return videoTracks;\n    }\n\n    /**\n     * Get the original audio tracks\n     * @function _getAudioTracks\n     * @returns {Array<Object>} - The original audio tracks\n     * @private\n     */\n\n  }, {\n    key: '_getAudioTracks',\n    value: function _getAudioTracks() {\n      var variantTracks = this._shaka.getVariantTracks();\n      var activeVariantTrack = variantTracks.filter(function (variantTrack) {\n        return variantTrack.active;\n      })[0];\n      var audioTracks = variantTracks.filter(function (variantTrack) {\n        return variantTrack.videoId === activeVariantTrack.videoId;\n      });\n      return audioTracks;\n    }\n\n    /**\n     * Get the parsed tracks\n     * @function _getParsedTracks\n     * @returns {Array<Track>} - The parsed tracks\n     * @private\n     */\n\n  }, {\n    key: '_getParsedTracks',\n    value: function _getParsedTracks() {\n      var videoTracks = this._getParsedVideoTracks();\n      var audioTracks = this._getParsedAudioTracks();\n      var textTracks = this._getParsedTextTracks();\n      return videoTracks.concat(audioTracks).concat(textTracks);\n    }\n\n    /**\n     * Get the parsed video tracks\n     * @function _getParsedVideoTracks\n     * @returns {Array<VideoTrack>} - The parsed video tracks\n     * @private\n     */\n\n  }, {\n    key: '_getParsedVideoTracks',\n    value: function _getParsedVideoTracks() {\n      var videoTracks = this._getVideoTracks();\n      var parsedTracks = [];\n      if (videoTracks) {\n        for (var i = 0; i < videoTracks.length; i++) {\n          var settings = {\n            id: videoTracks[i].id,\n            bandwidth: videoTracks[i].bandwidth,\n            active: videoTracks[i].active,\n            label: videoTracks[i].label,\n            index: i\n          };\n          parsedTracks.push(new _playkitJs.VideoTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\n     * Get the parsed audio tracks\n     * @function _getParsedAudioTracks\n     * @returns {Array<AudioTrack>} - The parsed audio tracks\n     * @private\n     */\n\n  }, {\n    key: '_getParsedAudioTracks',\n    value: function _getParsedAudioTracks() {\n      var audioTracks = this._getAudioTracks();\n      var parsedTracks = [];\n      if (audioTracks) {\n        for (var i = 0; i < audioTracks.length; i++) {\n          var settings = {\n            id: audioTracks[i].id,\n            active: audioTracks[i].active,\n            label: audioTracks[i].label,\n            language: audioTracks[i].language,\n            index: i\n          };\n          parsedTracks.push(new _playkitJs.AudioTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\n     * Get the parsed text tracks\n     * @function _getParsedTextTracks\n     * @returns {Array<TextTrack>} - The parsed text tracks\n     * @private\n     */\n\n  }, {\n    key: '_getParsedTextTracks',\n    value: function _getParsedTextTracks() {\n      var textTracks = this._shaka.getTextTracks();\n      var parsedTracks = [];\n      if (textTracks) {\n        for (var i = 0; i < textTracks.length; i++) {\n          var settings = {\n            kind: textTracks[i].kind ? textTracks[i].kind + 's' : \"\",\n            active: textTracks[i].active,\n            label: textTracks[i].label,\n            language: textTracks[i].language,\n            index: i\n          };\n          parsedTracks.push(new _playkitJs.TextTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\n     * Select a video track\n     * @function selectVideoTrack\n     * @param {VideoTrack} videoTrack - the video track to select\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectVideoTrack',\n    value: function selectVideoTrack(videoTrack) {\n      var videoTracks = this._getVideoTracks();\n      if (videoTrack instanceof _playkitJs.VideoTrack && videoTracks) {\n        var selectedVideoTrack = videoTracks[videoTrack.index];\n        if (selectedVideoTrack) {\n          this._shaka.configure({ abr: { enabled: false } });\n          if (!selectedVideoTrack.active) {\n            this._shaka.selectVariantTrack(videoTracks[videoTrack.index], true);\n            this._onTrackChanged(videoTrack);\n          }\n        }\n      }\n    }\n\n    /**\n     * Select an audio track\n     * @function selectAudioTrack\n     * @param {AudioTrack} audioTrack - the audio track to select\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectAudioTrack',\n    value: function selectAudioTrack(audioTrack) {\n      if (audioTrack instanceof _playkitJs.AudioTrack && !audioTrack.active) {\n        this._shaka.selectAudioLanguage(audioTrack.language);\n        this._onTrackChanged(audioTrack);\n      }\n    }\n\n    /**\n     * Select a text track\n     * @function selectTextTrack\n     * @param {TextTrack} textTrack - the track to select\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectTextTrack',\n    value: function selectTextTrack(textTrack) {\n      if (textTrack instanceof _playkitJs.TextTrack && !textTrack.active && (textTrack.kind === 'subtitles' || textTrack.kind === 'captions')) {\n        this._shaka.selectTextLanguage(textTrack.language);\n        this._shaka.setTextTrackVisibility(true);\n        this._onTrackChanged(textTrack);\n      }\n    }\n\n    /**\n     * Hide the text track\n     * @function hideTextTrack\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'hideTextTrack',\n    value: function hideTextTrack() {\n      this._shaka.setTextTrackVisibility(false);\n    }\n\n    /**\n     * Enables adaptive bitrate switching\n     * @function enableAdaptiveBitrate\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'enableAdaptiveBitrate',\n    value: function enableAdaptiveBitrate() {\n      this._shaka.configure({ abr: { enabled: true } });\n    }\n\n    /**\n     * An handler to shaka adaptation event\n     * @function _onAdaptation\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_onAdaptation',\n    value: function _onAdaptation() {\n      var selectedVideoTrack = this._getParsedVideoTracks().filter(function (videoTrack) {\n        return videoTrack.active;\n      })[0];\n      this._onTrackChanged(selectedVideoTrack);\n    }\n\n    /**\n     * An handler to shaka error event\n     * @function _onError\n     * @param {any} error - the error\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(error) {\n      DashAdapter._logger.error(error);\n    }\n\n    /**\n     * Getter for the src that the adapter plays on the video element.\n     * In case the adapter preformed a load it will return the manifest url.\n     * @public\n     * @returns {string} - The src url.\n     */\n\n  }, {\n    key: 'src',\n    get: function get() {\n      if (this._loadPromise && this._sourceObj) {\n        return this._sourceObj.url;\n      }\n      return \"\";\n    }\n  }]);\n\n  return DashAdapter;\n}(_playkitJs.BaseMediaSourceAdapter);\n\n// Register DashAdapter to the media source adapter manager\n\n\nDashAdapter.id = 'DashAdapter';\nDashAdapter._logger = _playkitJs.BaseMediaSourceAdapter.getLogger(DashAdapter.id);\nDashAdapter._dashMimeType = 'application/dash+xml';\nexports.default = DashAdapter;\nif (DashAdapter.isSupported()) {\n  (0, _playkitJs.registerMediaSourceAdapter)(DashAdapter);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// playkit-dash.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b043c7de86c1cf8ad84e","// @flow\nimport shaka from 'shaka-player';\nimport {registerMediaSourceAdapter, BaseMediaSourceAdapter} from 'playkit-js'\nimport {Track, VideoTrack, AudioTrack, TextTrack} from 'playkit-js'\n\n/**\n * Adapter of shaka lib for dash content\n * @classdesc\n */\nexport default class DashAdapter extends BaseMediaSourceAdapter {\n  /**\n   * The id of Adapter\n   * @member {string} id\n   * @static\n   * @public\n   */\n  static id = 'DashAdapter';\n  /**\n   * The adapter logger\n   * @member {any} _logger\n   * @private\n   * @static\n   */\n  static _logger = BaseMediaSourceAdapter.getLogger(DashAdapter.id);\n  /**\n   * The supported mime type by the dash adapter\n   * @member {string} _dashMimeType\n   * @static\n   * @private\n   */\n  static _dashMimeType = 'application/dash+xml';\n  /**\n   * The shaka player instance\n   * @member {any} _shaka\n   * @private\n   */\n  _shaka: any;\n  /**\n   * The load promise\n   * @member {Promise<Object>} - _loadPromise\n   * @type {Promise<Object>}\n   * @private\n   */\n  _loadPromise: ?Promise<Object>;\n\n  /**\n   * Factory method to create media source adapter.\n   * @function createAdapter\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n   * @param {Object} source - The source Object.\n   * @param {Object} config - The player configuration.\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n   * @static\n   */\n  static createAdapter(videoElement: HTMLVideoElement, source: Source, config: Object): IMediaSourceAdapter {\n    return new this(videoElement, source, config.playback.options.html5.dash);\n  }\n\n  /**\n   * Checks if dash adapter can play a given mime type\n   * @function canPlayType\n   * @param {string} mimeType - The mime type to check\n   * @returns {boolean} - Whether the dash adapter can play a specific mime type\n   * @static\n   */\n  static canPlayType(mimeType: string): boolean {\n    let canPlayType = typeof mimeType === 'string' ? mimeType.toLowerCase() === DashAdapter._dashMimeType : false;\n    DashAdapter._logger.debug('canPlayType result for mimeType: ' + mimeType + ' is ' + canPlayType.toString());\n    return canPlayType;\n  }\n\n  /**\n   * Checks if the dash adapter is supported\n   * @function isSupported\n   * @returns {boolean} -  Whether dash is supported.\n   * @static\n   */\n  static isSupported(): boolean {\n    shaka.polyfill.installAll();\n    let isSupported = shaka.Player.isBrowserSupported();\n    DashAdapter._logger.debug('isSupported:' + isSupported);\n    return isSupported;\n  }\n\n  /**\n   * @constructor\n   * @param {HTMLVideoElement} videoElement - The video element which bind to the dash adapter\n   * @param {Object} source - The source object\n   * @param {Object} config - The media source adapter configuration\n   */\n  constructor(videoElement: HTMLVideoElement, source: Object, config: Object = {}) {\n    DashAdapter._logger.debug('Creating adapter. Shaka version: ' + shaka.Player.version);\n    super(videoElement, source, config);\n    this._shaka = new shaka.Player(videoElement);\n    this._shaka.configure(config);\n    this._addBindings();\n  }\n\n  /**\n   * Add the required bindings to shaka.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n  _addBindings(): void {\n    this._shaka.addEventListener('adaptation', this._onAdaptation.bind(this));\n    this._shaka.addEventListener('error', this._onError.bind(this));\n  }\n\n  /**\n   * Remove the bindings to shaka.\n   * @function _removeBindings\n   * @private\n   * @returns {void}\n   */\n  _removeBindings(): void {\n    this._shaka.removeEventListener('adaptation', this._onAdaptation);\n    this._shaka.removeEventListener('error', this._onError);\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @override\n   */\n  load(): Promise<Object> {\n    if (!this._loadPromise) {\n      this._loadPromise = new Promise((resolve, reject) => {\n        if (this._sourceObj && this._sourceObj.url) {\n          this._shaka.load(this._sourceObj.url).then(() => {\n            let data = {tracks: this._getParsedTracks()};\n            DashAdapter._logger.debug('The source has been loaded successfully');\n            resolve(data);\n          }).catch((error) => {\n            reject(error);\n            this._onError(error);\n          });\n        }\n      });\n    }\n    return this._loadPromise;\n  }\n\n  /**\n   * Destroying the dash adapter\n   * @function destroy\n   * @override\n   */\n  destroy(): void {\n    DashAdapter._logger.debug('destroy');\n    super.destroy();\n    this._loadPromise = null;\n    this._removeBindings();\n    this._shaka.destroy();\n  }\n\n  /**\n   * Get the original video tracks\n   * @function _getVideoTracks\n   * @returns {Array<Object>} - The original video tracks\n   * @private\n   */\n  _getVideoTracks(): Array<Object> {\n    let variantTracks = this._shaka.getVariantTracks();\n    let activeVariantTrack = variantTracks.filter((variantTrack) => {\n      return variantTrack.active;\n    })[0];\n    let videoTracks = variantTracks.filter((variantTrack) => {\n      return variantTrack.audioId === activeVariantTrack.audioId;\n    });\n    return videoTracks;\n  }\n\n  /**\n   * Get the original audio tracks\n   * @function _getAudioTracks\n   * @returns {Array<Object>} - The original audio tracks\n   * @private\n   */\n  _getAudioTracks(): Array<Object> {\n    let variantTracks = this._shaka.getVariantTracks();\n    let activeVariantTrack = variantTracks.filter((variantTrack) => {\n      return variantTrack.active;\n    })[0];\n    let audioTracks = variantTracks.filter((variantTrack) => {\n      return variantTrack.videoId === activeVariantTrack.videoId;\n    });\n    return audioTracks;\n  }\n\n  /**\n   * Get the parsed tracks\n   * @function _getParsedTracks\n   * @returns {Array<Track>} - The parsed tracks\n   * @private\n   */\n  _getParsedTracks(): Array<Track> {\n    let videoTracks = this._getParsedVideoTracks();\n    let audioTracks = this._getParsedAudioTracks();\n    let textTracks = this._getParsedTextTracks();\n    return videoTracks.concat(audioTracks).concat(textTracks);\n  }\n\n  /**\n   * Get the parsed video tracks\n   * @function _getParsedVideoTracks\n   * @returns {Array<VideoTrack>} - The parsed video tracks\n   * @private\n   */\n  _getParsedVideoTracks(): Array<VideoTrack> {\n    let videoTracks = this._getVideoTracks();\n    let parsedTracks = [];\n    if (videoTracks) {\n      for (let i = 0; i < videoTracks.length; i++) {\n        let settings = {\n          id: videoTracks[i].id,\n          bandwidth: videoTracks[i].bandwidth,\n          active: videoTracks[i].active,\n          label: videoTracks[i].label,\n          index: i\n        };\n        parsedTracks.push(new VideoTrack(settings));\n      }\n    }\n    return parsedTracks;\n  }\n\n  /**\n   * Get the parsed audio tracks\n   * @function _getParsedAudioTracks\n   * @returns {Array<AudioTrack>} - The parsed audio tracks\n   * @private\n   */\n  _getParsedAudioTracks(): Array<AudioTrack> {\n    let audioTracks = this._getAudioTracks();\n    let parsedTracks = [];\n    if (audioTracks) {\n      for (let i = 0; i < audioTracks.length; i++) {\n        let settings = {\n          id: audioTracks[i].id,\n          active: audioTracks[i].active,\n          label: audioTracks[i].label,\n          language: audioTracks[i].language,\n          index: i\n        };\n        parsedTracks.push(new AudioTrack(settings));\n      }\n    }\n    return parsedTracks;\n  }\n\n  /**\n   * Get the parsed text tracks\n   * @function _getParsedTextTracks\n   * @returns {Array<TextTrack>} - The parsed text tracks\n   * @private\n   */\n  _getParsedTextTracks(): Array<TextTrack> {\n    let textTracks = this._shaka.getTextTracks();\n    let parsedTracks = [];\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        let settings = {\n          kind: textTracks[i].kind ? textTracks[i].kind + 's' : \"\",\n          active: textTracks[i].active,\n          label: textTracks[i].label,\n          language: textTracks[i].language,\n          index: i\n        };\n        parsedTracks.push(new TextTrack(settings));\n      }\n    }\n    return parsedTracks;\n  }\n\n  /**\n   * Select a video track\n   * @function selectVideoTrack\n   * @param {VideoTrack} videoTrack - the video track to select\n   * @returns {void}\n   * @public\n   */\n  selectVideoTrack(videoTrack: VideoTrack): void {\n    let videoTracks = this._getVideoTracks();\n    if ((videoTrack instanceof VideoTrack) && videoTracks) {\n      let selectedVideoTrack = videoTracks[videoTrack.index];\n      if (selectedVideoTrack) {\n        this._shaka.configure({abr: {enabled: false}});\n        if (!selectedVideoTrack.active) {\n          this._shaka.selectVariantTrack(videoTracks[videoTrack.index], true);\n          this._onTrackChanged(videoTrack);\n        }\n      }\n    }\n  }\n\n  /**\n   * Select an audio track\n   * @function selectAudioTrack\n   * @param {AudioTrack} audioTrack - the audio track to select\n   * @returns {void}\n   * @public\n   */\n  selectAudioTrack(audioTrack: AudioTrack): void {\n    if ((audioTrack instanceof AudioTrack) && !audioTrack.active) {\n      this._shaka.selectAudioLanguage(audioTrack.language);\n      this._onTrackChanged(audioTrack);\n    }\n  }\n\n  /**\n   * Select a text track\n   * @function selectTextTrack\n   * @param {TextTrack} textTrack - the track to select\n   * @returns {void}\n   * @public\n   */\n  selectTextTrack(textTrack: TextTrack): void {\n    if ((textTrack instanceof TextTrack) && !textTrack.active && (textTrack.kind === 'subtitles' || textTrack.kind === 'captions')) {\n      this._shaka.selectTextLanguage(textTrack.language);\n      this._shaka.setTextTrackVisibility(true);\n      this._onTrackChanged(textTrack);\n    }\n  }\n\n  /**\n   * Hide the text track\n   * @function hideTextTrack\n   * @returns {void}\n   * @public\n   */\n  hideTextTrack(): void {\n    this._shaka.setTextTrackVisibility(false);\n  }\n\n  /**\n   * Enables adaptive bitrate switching\n   * @function enableAdaptiveBitrate\n   * @returns {void}\n   * @public\n   */\n  enableAdaptiveBitrate(): void {\n    this._shaka.configure({abr: {enabled: true}});\n  }\n\n  /**\n   * An handler to shaka adaptation event\n   * @function _onAdaptation\n   * @returns {void}\n   * @private\n   */\n  _onAdaptation(): void {\n    let selectedVideoTrack = this._getParsedVideoTracks().filter(function (videoTrack) {\n      return videoTrack.active;\n    })[0];\n    this._onTrackChanged(selectedVideoTrack);\n  }\n\n  /**\n   * An handler to shaka error event\n   * @function _onError\n   * @param {any} error - the error\n   * @returns {void}\n   * @private\n   */\n  _onError(error: any): void {\n    DashAdapter._logger.error(error);\n  }\n\n  /**\n   * Getter for the src that the adapter plays on the video element.\n   * In case the adapter preformed a load it will return the manifest url.\n   * @public\n   * @returns {string} - The src url.\n   */\n  get src(): string {\n    if (this._loadPromise && this._sourceObj) {\n      return this._sourceObj.url;\n    }\n    return \"\";\n  }\n}\n\n// Register DashAdapter to the media source adapter manager\nif (DashAdapter.isSupported()) {\n  registerMediaSourceAdapter(DashAdapter);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./dash-adapter.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":\"shaka\"}\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}